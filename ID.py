# -*- coding: utf-8 -*-
"""
Inverse Dynamics: calculates joint torques required to produce joint angles 
over time generated by IK 
@author: Jack Vincent
"""

import math
import numpy as np
from progressbar import ProgressBar, Percentage, Bar, ETA
from scipy.interpolate import UnivariateSpline
from scipy.optimize import Bounds, minimize

import model

# load in model and experiment
current_model = model.load('upper_arm_0')
current_experiment = model.load('8-17-20')

t = current_experiment.t

# creates interpolation function that can be called to determine the joint 
# angles at any time point within the recorded range, even time points that 
# were not explicitly calculated
for joint_data in current_experiment.joints:
    angle = joint_data.angle
    joint_data.angle_interp = UnivariateSpline(t, angle, s=0)

# iterate joint by joint
for joint_data in current_experiment.joints:
    velocity = []
    for time in t:
        vel = joint_data.angle_interp.derivative(n=1)(time)
        velocity.append(vel)
    joint_data.velocity = velocity
    
# iterate joint by joint
for joint_data in current_experiment.joints:
    acceleration = []
    for time in t:
        accel = joint_data.angle_interp.derivative(n=2)(time)
        acceleration.append(accel)
    joint_data.acceleration = acceleration
    
for joint_data in current_experiment.joints:
    joint_data.torque = []
    joint_data.torque_no_grav = []
    
for time in t:
    torques = current_experiment.return_torques(time)
    for i, joint_data in enumerate(current_experiment.joints):
        joint_data.torque.append(torques[i])
        
    torques_no_grav = current_experiment.return_torques_no_grav(time)
    for i, joint_data in enumerate(current_experiment.joints):
        joint_data.torque_no_grav.append(torques_no_grav[i])
    
        
# create muscle data objects for muscle tracker
muscle_datas = []
for muscle in current_model.musculature.muscles:
    muscle_datas.append(model.MuscleData(muscle.name, muscle))
    
current_muscle_tracker = model.MuscleTracker('test', muscle_datas, 
                                             current_experiment, current_model)
current_muscle_tracker.calc_muscle_lengths()


# function to be minimized 
def calc_muscle_act(muscle_acts, *args):

    lengths = []
    
    # scale activations by muscle lengths
    for j, muscle_data in enumerate(current_muscle_tracker.muscles):
        lengths.append(muscle_data.length_interp(time)/current_model.musculature.muscles[j].optimal_fiber_length)
    
    # adjust muscle activations by length factor
    adjusted_acts = []
    for j, act in enumerate(muscle_acts):
        l_m = lengths[j]
        F_l = np.exp(((-1) * ((l_m - 1)**2))/0.45)
        post_length = act*F_l
        adjusted_acts.append(post_length)
        
    # create dictionary with keys = muscle names and values = activation level 
    # (adjusted for length)
    muscle_activations = {}
    for j, act in enumerate(adjusted_acts):
        muscle_activations[current_model.musculature.muscles[j].name] = adjusted_acts[j]
        
    joint_torques = np.zeros(len(current_model.skeleton.joints))
    for j, joint in enumerate(current_model.skeleton.joints):
        current_joint = joint.name
        
        for muscle in current_model.musculature.muscles:
            if muscle.joint == current_joint:
                if muscle.rotation == joint.rotation:
                    joint_torques[j] += muscle_activations[muscle.name] * \
                        muscle.F_max * (joint.diameter/2)
                else:
                    joint_torques[j] += (-1) * \
                        muscle_activations[muscle.name] * muscle.F_max * \
                            (joint.diameter/2)
                            
    torque_error = math.sqrt(sum((px - qx) ** 2.0 for px, qx in zip(joint_torques, target_torques)))
    
    act_error = 0
    for act in muscle_acts:
        act_error += act**2  
    
    deviation_error = math.sqrt(sum((px - qx) ** 2.0 for px, qx in zip(x0, muscle_acts)))
    
    return (1000*torque_error) + act_error + (10*deviation_error)

# widgets for the progress bar
widgets = ['PROGRESS: ', Percentage(), ' ',
              Bar(marker='-',left='[',right=']\n'),
               ' ', ETA(),' \n ']

# create a progress bar object
pbar = ProgressBar(maxval=len(current_experiment.t),widgets=widgets).start()

# bounds on muscle activations
lb = []
ub = []
for muscle in current_model.musculature.muscles:
    lb.append(muscle.min_act)
    ub.append(muscle.max_act)
    
# Bounds function in scipy    
bounds = Bounds(lb, ub)
    
# iterate through every endpoint (other than first one)
for i, time in enumerate(current_experiment.t):
    
    # update progress bar
    pbar.update(i+1)

    x0 = []
    for muscle in current_muscle_tracker.muscles:
        try:
            x0.append(muscle.activation[-1])
        except IndexError:
            x0.append(0.1)
            
    # current torques being solved for
    target_torques = []
    for joint_data in current_experiment.joints:
        target_torques.append(joint_data.torque[i])

    # stuff the function we're minimizing needs to have access to
    args = (current_model, target_torques, current_muscle_tracker, i, time)

    # minimize function using SLSQP
    res = minimize(calc_muscle_act, x0, method='TNC', 
                   options={'verbose': 0, 'ftol': 1e-10}, bounds=bounds)

    for j, activ in enumerate(res.x):
        current_muscle_tracker.muscles[j].activation.append(activ)
    
tau = 0.01
for muscle_data in current_muscle_tracker.muscles:
    muscle_data.activation_interp = UnivariateSpline(t, muscle_data.activation, s=0)
    for i, time in enumerate(t):
        dadt = muscle_data.activation_interp.derivative(n=1)(time)
        u = (dadt*tau) + muscle_data.activation_interp(time)
        muscle_data.excitation.append(u)
        
# end progress bar    
pbar.finish() 
    
# write finished results
current_model.dump()
current_experiment.dump()
current_muscle_tracker.dump()
    